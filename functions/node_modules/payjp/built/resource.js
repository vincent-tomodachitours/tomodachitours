"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
/// <reference types="node" />
const superagent = require("superagent");
class Resource {
    payjp;
    constructor(payjp) {
        this.payjp = payjp;
    }
    get apibase() {
        return this.payjp.config.apibase;
    }
    get apikey() {
        return this.payjp.apikey;
    }
    buildHeader(method) {
        const encodedKey = Buffer.from(`${this.payjp.apikey}:`).toString('base64');
        const headers = {
            Accept: 'application/json',
            Authorization: `Basic ${encodedKey}`
        };
        if (method === 'POST') {
            headers['Content-Type'] = 'application/x-www-form-urlencoded';
        }
        return headers;
    }
    getCurrentDelay(retryCount, initialDelay, maxDelay) {
        const delay = Math.min(initialDelay * 2 ** retryCount, maxDelay);
        return Math.ceil(delay / 2 * (1 + Math.random()));
    }
    request(method, endpoint, query = {}, headers = {}) {
        const url = `${this.payjp.config.apibase}/${endpoint}`;
        const header = Object.assign(this.buildHeader(method), headers);
        const doRequest = () => {
            let request = superagent(method, url).set(header);
            if (method === 'GET' || method === 'DELETE') {
                request = request.query(query);
            }
            else { // (method === 'POST' || method === 'PUT')
                request = request.send(query);
            }
            if (this.payjp.config.timeout > 0) {
                request = request.timeout(this.payjp.config.timeout);
            }
            return request;
        };
        let retryCount = 0;
        const retry = (resolve, reject) => doRequest().then(resolve).catch((res) => {
            if (res.status === 429 && retryCount < this.payjp.config.maxRetry) {
                const delayWithJitter = this.getCurrentDelay(retryCount, this.payjp.config.retryInitialDelay, this.payjp.config.retryMaxDelay);
                retryCount++;
                setTimeout(() => retry(resolve, reject), delayWithJitter);
            }
            else {
                return reject(res);
            }
        });
        return new Promise(retry).then(res => res.body);
    }
}
exports.default = Resource;
